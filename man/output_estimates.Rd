% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/adaptive_utils.R
\name{output_estimates}
\alias{output_estimates}
\title{Calculate treatment effect estimates using AIPW with various weighting schemes}
\usage{
output_estimates(
  policy0 = NULL,
  policy1,
  contrasts = "combined",
  gammahat,
  contextual_probs,
  uniform = TRUE,
  non_contextual_minvar = TRUE,
  contextual_minvar = TRUE,
  non_contextual_stablevar = TRUE,
  contextual_stablevar = TRUE,
  non_contextual_twopoint = TRUE
)
}
\arguments{
\item{policy0}{A * K control policy matrix for contrast evaluation, with probabilities under control. When `policy0 = NULL`, the function is estimating the value \eqn{Q(w)} of a single arm w. When `policy0` doesn't equal to `NULL`, the function is estimating treatment effects of policies as compared to control \eqn{\Delta(w_1, w_2)}, using the difference in AIPW scores as the unbiased scoring rule for \eqn{\Delta (w_1, w_2)}.}

\item{policy1}{list of A * K counterfactual treatment policy matrices for evaluation, with assignment probabilities under each policy.}

\item{contrasts}{Define the approach to estimate treatment effects. `combined` indicates the first approach -- the difference in AIPW scores as the unbiased scoring rule for \eqn{\Delta (w_1, w_2)}; `separate` indicates the second approach -- \eqn{\hat \Delta (w_1, w_2) = \hat Q (w_1) - \hat Q (w_2)}.}

\item{gammahat}{Scores matrix.}

\item{contextual_probs}{A * A * K matrix for contextual probabilities, with dimensions representing time, contexts, treatment arms.}

\item{uniform}{Logical, estimate uniform weights.}

\item{non_contextual_minvar}{Logical, estimate non-contextual minvar weights.}

\item{contextual_minvar}{Logical, estimate contextual minvar weights.}

\item{non_contextual_stablevar}{Logical, estimate non-contextual stablevar weights.}

\item{contextual_stablevar}{Logical, estimate contextual stablevar weights.}

\item{non_contextual_twopoint}{The non_contextual_twopoint parameter.}
}
\value{
A list of treatment effect estimates under different weighting schemes.
}
\description{
This function calculates treatment effect estimates using augmented inverse probability weighting (AIPW) with various weighting schemes. The function estimates the value of a single arm or treatment effects of policies as compared to the control, using the difference in AIPW scores as the unbiased scoring rule or the difference in means between two policies. The function provides estimates under various weighting schemes, including uniform, non-contextual minvar, contextual minvar, non-contextual stablevar, contextual stablevar, and non-contextual two-point. The function is based on the algorithm developed in Zhan et al. (2021).
}
\examples{
# Generate example values for policy1, gammahat, and contextual_probs
scores <- matrix(c(0.5, 0.8, 0.6,
                   0.3, 0.9, 0.2,
                   0.5, 0.7, 0.4,
                   0.8, 0.2, 0.6), ncol = 3)
policy <- matrix(c(0.2, 0.3, 0.5,
                   0.6, 0.1, 0.3,
                   0.4, 0.5, 0.1,
                   0.2, 0.7, 0.1), ncol = 3)
gammahat <- scores - policy

# Ensure the rows of policy1 sum to 1
temp_policy1 <- matrix(runif(4*3), ncol = 3)
policy1 <- list(temp_policy1 / rowSums(temp_policy1))

# Ensure the rows of policy0 sum to 1
temp_policy0 <- matrix(runif(4*3), ncol = 3)
policy0 <- temp_policy0 / rowSums(temp_policy0)

contextual_probs <- array(0, dim = c(4, 4, 3))
for (i in 1:4) {
  temp_vector <- runif(3)
  normalized_vector <- temp_vector / sum(temp_vector)
  contextual_probs[i, 1, ] <- normalized_vector
  }
  for (k in 1:3) {
    for (i in 1:4) {
    temp_vector <- runif(3)
    normalized_vector <- temp_vector / sum(temp_vector)
    contextual_probs[i, 2:4, k] <- normalized_vector
      }
   }
estimates <- output_estimates(policy1 = policy1,
                              policy0 = policy0,
                              gammahat = gammahat,
                              contextual_probs = contextual_probs)
plot
plot_results_baseR <- function(result) {
  estimates <- result[, "estimate"]
  std_errors <- result[, "std.error"]
  labels <- rownames(result)

  # Define the limits for the x-axis based on estimates and std_errors
  xlims <- c(min(estimates - std_errors), max(estimates + std_errors))

  # Create the basic error bar plot using base R
  invisible(
    plot(estimates, 1:length(estimates), xlim=xlims, xaxt="n", xlab="Coefficient Estimate", ylab="",
         yaxt="n", pch=16, las=1, main="Coefficients and CIs")
  )

  # Add y-axis labels
  invisible(
    axis(2, at=1:length(estimates), labels=labels, las=1, tick=FALSE, line=0.5)
  )

  # Add the x-axis values
  x_ticks <- seq(from=xlims[1], to=xlims[2], by=0.1)
  invisible(
    axis(1, at=x_ticks[x_ticks > max(estimates + std_errors) | x_ticks < min(estimates - std_errors)],
         labels=x_ticks[x_ticks > max(estimates + std_errors) | x_ticks < min(estimates - std_errors)])
  )

  # Add error bars
  invisible(
    segments(estimates - std_errors, 1:length(estimates), estimates + std_errors, 1:length(estimates))
  )
}

sample_result <- estimates[[1]]
par(mar=c(5, 12, 4, 2))
plot_results_baseR(sample_result)

}
